use crate::formatter::format_source_code;
use crate::{
    extractor::{
        BindingDefinition, BindingType, CodeMacroDefinition, Colored, ConstantDefinition, DataDefinition, Definition, Documented, Field,
        FunctionDefinition, IndexMacroDefinition, ItemContent, ModuleDefinition, NamedSignature, SignatureInfo, VariantDefinition,
    },
    summarizer::{DocumentationSummary, RenderingContent, RenderingItem},
};
use kuchiki::traits::TendrilSink;
use leptos::{html::Div, view, CollectView, HtmlElement, IntoView, View};
use rand::distributions::Alphanumeric;
use rand::{thread_rng, Rng};
use std::collections::HashMap;
use std::fs::{create_dir_all, remove_dir_all};
use std::path::{Path, PathBuf};
use thiserror::Error;

#[derive(Error, Debug)]
pub enum GenerationError {}

pub fn generate_documentation_site(directory: &Path, summary: DocumentationSummary) -> Result<(), GenerationError> {
    let output_directory = directory.join("doc-site");
    remove_dir_all(output_directory.clone()).expect("Unable to remove existing output directory");
    create_dir_all(output_directory.clone()).expect("Unable to create output directory");

    let mut mangler = FilenameMangler::new();

    save_static_file(
        &output_directory,
        mangler.mangle_filename("style.css".as_ref()),
        include_bytes!("../design/style.css"),
    );

    save_static_file(
        &output_directory,
        mangler.mangle_filename("script.js".as_ref()),
        include_bytes!("../design/script.js"),
    );

    save_static_file(&output_directory, "Uiua386.ttf".parse().unwrap(), include_bytes!("../design/Uiua386.ttf"));

    save_static_file(
        &output_directory,
        "index.html".parse().unwrap(),
        generate_html(summary, &mut mangler).as_bytes(),
    );

    Ok(())
}

struct FilenameMangler {
    map: HashMap<PathBuf, PathBuf>,
}

impl FilenameMangler {
    fn new() -> Self {
        Self { map: HashMap::new() }
    }

    fn mangle_filename(&mut self, path: &Path) -> PathBuf {
        let mut rng = thread_rng();
        let random_string: String = (0..8).map(|_| rng.sample(Alphanumeric) as char).collect();

        let mut new_filename = path.file_stem().unwrap().to_os_string();
        new_filename.push(".");
        new_filename.push(&random_string);
        if let Some(ext) = path.extension() {
            new_filename.push(".");
            new_filename.push(ext);
        }

        let mangled_path = path.with_file_name(new_filename);
        self.map.insert(path.to_path_buf(), mangled_path.clone());
        mangled_path
    }

    fn get_mangled_filename(&self, original: &Path) -> Option<&PathBuf> {
        self.map.get(original)
    }
}

fn save_static_file(output_directory: &Path, file: PathBuf, content: &[u8]) {
    let destination = output_directory.join(file);
    std::fs::write(destination, content).expect("Unable to write static file");
}

fn generate_html(summary: DocumentationSummary, mangler: &mut FilenameMangler) -> String {
    let page_content = generate_page(summary, mangler);
    let raw_output = leptos::ssr::render_to_string(|| page_content).to_string();
    let document = kuchiki::parse_html().from_utf8().one(raw_output.as_bytes());

    // Remove comments
    document
        .inclusive_descendants()
        .filter(|node| node.as_comment().is_some())
        .for_each(|comment| comment.detach());

    // Remove data-hk attributes generated by leptos
    document.select("[data-hk]").unwrap().for_each(|node| {
        node.attributes.borrow_mut().remove("data-hk");
    });

    // Serialize back to string
    let mut result = Vec::new();
    document.serialize(&mut result).unwrap();
    String::from_utf8(result).unwrap()
}

fn markdown_to_html(markdown: &str) -> String {
    markdown::to_html_with_options(markdown, &markdown::Options::gfm())
        .expect("Unable to convert markdown to HTML")
        .replace('\n', "<br/>")
}

fn generate_page(summary: DocumentationSummary, mangler: &mut FilenameMangler) -> impl IntoView {
    let stylesheet = mangler.get_mangled_filename("style.css".as_ref()).unwrap().to_str().unwrap().to_string();
    let script = mangler.get_mangled_filename("script.js".as_ref()).unwrap().to_str().unwrap().to_string();

    view! {
        <!DOCTYPE html>
        <html lang="en">
            <head>
                <title>{&summary.title}</title>
                <meta charset="utf-8" />
                <meta name="viewport" content="width=device-width, initial-scale=1.0" />
                <link rel="stylesheet" href=stylesheet />
                <script src=script></script>
            </head>
            <body>
                <div class="mobile-container">
                    <div class="mobile-nav">
                        <div class="hamburger">
                            <div class="line"></div>
                            <div class="line"></div>
                            <div class="line"></div>
                        </div>
                        <h1>{&summary.title}</h1>
                    </div>
                    <div class="container">
                        <div class="sidebar">{generate_sidebar(&summary)}</div>
                        <div class="content">
                            <div class="content-wrapper">
                                <h1 class="mobile-hidden">{&summary.title}</h1>
                                {generate_content(&summary)}
                            </div>
                        </div>
                    </div>
                </div>
            </body>
        </html>
    }
}

fn generate_sidebar(summary: &DocumentationSummary) -> impl IntoView {
    summary
        .sections
        .iter()
        .map(|section| {
            view! {
                <div class="sidebar-section">
                    <div class="section-name">{&section.title}</div>
                    <ul>
                        {section
                            .content
                            .iter()
                            .flat_map(|item| &item.links)
                            .map(|link| {
                                view! {
                                    <li>
                                        <a href=&link.url>{&link.title}</a>
                                    </li>
                                }
                            })
                            .collect_view()}
                        {section
                            .content
                            .iter()
                            .filter(|item| matches!(&item.content, RenderingContent::Items(_)))
                            .map(|link| match &link.content {
                                RenderingContent::Items(items) => {
                                    view! {
                                        <li>
                                            <a href=format!(
                                                "#{}",
                                                &items.title.link_id,
                                            )>{&items.title.title}</a>
                                        </li>
                                    }
                                }
                                _ => view! { <li>"N/A"</li> },
                            })
                            .collect_view()}
                    </ul>
                </div>
            }
        })
        .collect_view()
}

fn generate_content(summary: &DocumentationSummary) -> impl IntoView {
    summary
        .sections
        .iter()
        .map(|section| section.content.iter().map(|item| generate_rendering_item(item)).collect_view())
        .collect_view()
}

fn generate_rendering_item(item: &RenderingItem) -> impl IntoView {
    match &item.content {
        RenderingContent::RenderedDocumentation(ref content) => view! { <div class="panel" inner_html=content></div> },
        RenderingContent::Items(ref item) => view! {
            <div>
                <h2 id=&item.title.link_id>{&item.title.title}</h2>
                {item.items.iter().map(|item| generate_content_item(None, item)).collect_view()}
            </div>
        },
    }
}

fn generate_content_item(parent_module: Option<String>, item: &ItemContent) -> HtmlElement<Div> {
    match item {
        ItemContent::Binding(binding) => generate_binding_item(parent_module, binding),
        ItemContent::Module(module) => generate_module_item(parent_module, module),
        ItemContent::Data(data) => generate_data_item(parent_module, data),
        ItemContent::Variant(variant) => generate_variant_item(parent_module, variant),
        _ => view! { <div class="panel">{format!("{:?}", item)}</div> },
    }
}

fn generate_binding_item(parent_module: Option<String>, item: &BindingDefinition) -> HtmlElement<Div> {
    match &item.kind {
        BindingType::Const(constant) => generate_constant_item(parent_module, item, constant),
        BindingType::Function(function) => generate_function_item(parent_module, item, function),
        BindingType::IndexMacro(index_macro) => generate_index_macro_item(parent_module, item, index_macro),
        BindingType::CodeMacro(code_macro) => generate_code_macro_item(parent_module, item, code_macro),
    }
}

fn module_qualifier(module: String) -> View {
    view! {
        <span class="module">{module}</span>
        <span>"~"</span>
    }
    .into()
}

fn documentation(item: &impl Documented) -> impl IntoView {
    item.comment()
        .map(|comment| view! { <div class="feature-documentation" inner_html=markdown_to_html(comment) /> })
}

fn generate_constant_item(parent_module: Option<String>, item: &BindingDefinition, constant: &ConstantDefinition) -> HtmlElement<Div> {
    view! {
        <div class="panel feature">
            <h3 class="mono">
                {parent_module.clone().map(module_qualifier)} <span inner_html=&item.name></span>
                " " <span class="badge">"constant"</span>
            </h3>
            {constant
                .value
                .as_ref()
                .map(|value| {
                    view! {
                        <details>
                            <summary>"Literal value"</summary>
                            <code class="literal-value">{value}</code>
                        </details>
                    }
                })}
            {documentation(item)}
        </div>
    }
}

fn generate_named_signature_item(signature: Option<SignatureInfo>, named_signature: Option<NamedSignature>) -> HtmlElement<Div> {
    let hidden = if signature.is_none() && named_signature.is_none() {
        "hidden"
    } else {
        ""
    };

    view! {
        <div class=format!(
            "function-summary {}",
            hidden,
        )>
            {signature
                .map(|signature| {
                    view! { <span class="summary-badge signature">{format!("{signature}")}</span> }
                })}
            {named_signature
                .map(|signature| {
                    view! {
                        {signature
                            .outputs
                            .iter()
                            .map(|output| {
                                view! { <span class="summary-badge output">{output}</span> }
                            })
                            .collect_view()}
                        "?"
                        {signature
                            .inputs
                            .iter()
                            .map(|input| view! { <span class="summary-badge input">{input}</span> })
                            .collect_view()}
                    }
                })}
        </div>
    }
}

fn generate_function_item(parent_module: Option<String>, item: &BindingDefinition, function: &FunctionDefinition) -> HtmlElement<Div> {
    let source_code = format_source_code(&item.code);

    view! {
        <div class="panel feature">
            <h3 class="mono">
                {parent_module.map(module_qualifier)}
                <span class=function.signature.color_class()>{&item.name}</span> " "
                <span class="badge">"function"</span>
            </h3>

            {generate_named_signature_item(
                Some(function.signature.clone()),
                function.named_signature.clone(),
            )}
            {documentation(item)}

            <details>
                <summary>"Source code"</summary>
                <code class="source-code" inner_html=source_code></code>
            </details>
        </div>
    }
}

fn generate_index_macro_item(parent_module: Option<String>, item: &BindingDefinition, index_macro: &IndexMacroDefinition) -> HtmlElement<Div> {
    let source_code = format_source_code(&item.code);

    view! {
        <div class="panel feature">
            <h3 class="mono">
                {parent_module.map(module_qualifier)}
                <span class=index_macro.color_class()>{&item.name}</span> " "
                <span class="badge">"index macro"</span>
            </h3>

            {generate_named_signature_item(None, index_macro.named_signature.clone())}
            {documentation(item)}

            <details>
                <summary>"Source code"</summary>
                <code class="source-code" inner_html=source_code></code>
            </details>
        </div>
    }
}

fn generate_code_macro_item(parent_module: Option<String>, item: &BindingDefinition, index_macro: &CodeMacroDefinition) -> HtmlElement<Div> {
    let source_code = format_source_code(&item.code);

    view! {
        <div class="panel feature">
            <h3 class="mono">
                {parent_module.map(module_qualifier)}
                <span class="monadic-modifier">{&item.name}</span> " "
                <span class="badge">"code macro"</span>
            </h3>

            {generate_named_signature_item(None, index_macro.named_signature.clone())}
            {documentation(item)}

            <details>
                <summary>"Source code"</summary>
                <code class="source-code" inner_html=source_code></code>
            </details>
        </div>
    }
}

fn generate_module_item(parent_module: Option<String>, module: &ModuleDefinition) -> HtmlElement<Div> {
    view! {
        <div class="panel feature">
            <h3 class="mono">
                {parent_module.map(module_qualifier)} <span class="module">{&module.name}</span> " "
                <span class="badge">"module"</span>
            </h3>
            {documentation(module)}
            <br />
            {module
                .items
                .iter()
                .map(|item| generate_content_item(Some(module.name.clone()), item))
                .collect_view()}
        </div>
    }
}

pub fn box_description(definition: Option<&Definition>) -> &'static str {
    if let Some(def) = definition {
        if def.boxed {
            "boxed"
        } else {
            "unboxed"
        }
    } else {
        "no values"
    }
}

fn generate_data_item(parent_module: Option<String>, data: &DataDefinition) -> HtmlElement<Div> {
    fn badge_row(field: &Field) -> View {
        view! {
            <div class="badge-row">
                <span class="data-badge input">{&field.clone().name}</span>
                {&field
                    .validator
                    .clone()
                    .map(|validator| {
                        let (name, italics) = match validator.as_str() {
                            "°0type" => ("number array".into(), true),
                            "°1type" => ("complex array".into(), true),
                            "°2type" => ("box array".into(), true),
                            "°3type" => ("complex array".into(), true),
                            _ => (None, false),
                        };
                        let italics = if italics { "italics" } else { "" };
                        let name = if let Some(name) = name { name.to_string() } else { validator };

                        view! { <span class=format!("data-badge type {}", italics)>{name}</span> }
                    })
                    .collect_view()}
            </div>
        }
        .into_view()
    }

    view! {
        <div class="panel feature">
            <h3 class="mono">
                {parent_module.map(module_qualifier)}
                <span class="module">{data.name.clone().unwrap_or_default()}</span> " "
                <span class="badge">"data"</span> " "
                <span class="badge">{box_description(data.definition.as_ref())}</span>
            </h3>
            {documentation(data)}
            {data
                .definition
                .as_ref()
                .map(|definition| {
                    view! {
                        <div class="data-summary">
                            {definition.fields.iter().map(badge_row).collect_view()}
                        </div>
                    }
                })}
        </div>
    }
}

fn generate_variant_item(parent_module: Option<String>, data: &VariantDefinition) -> HtmlElement<Div> {
    view! {
        <div class="panel feature">
            <h3 class="mono">
                {parent_module.map(module_qualifier)} <span class="module">{&data.name}</span> " "
                <span class="badge">"variant"</span> " "
                <span class="badge">{box_description(data.definition.as_ref())}</span>
            </h3>
            {documentation(data)}
            {data
                .definition
                .as_ref()
                .map(|definition| {
                    view! {
                        <div class="data-summary variant">
                            {definition
                                .fields
                                .iter()
                                .map(|field| {
                                    view! {
                                        <div class="badge-row">
                                            <span class="data-badge input">{&field.name}</span>
                                        </div>
                                    }
                                })
                                .collect_view()}
                        </div>
                    }
                })}
        </div>
    }
}
