use std::fs::{create_dir_all, remove_dir};
use std::path::PathBuf;
use kuchiki::traits::TendrilSink;
use leptos::{view, CollectView, HtmlElement, IntoView};
use leptos::html::Div;
use thiserror::Error;
use crate::extractor::{BindingDefinition, BindingType, CodeMacroDefinition, ConstantDefinition, DataDefinition, FunctionDefinition, IndexMacroDefinition, ItemContent, ModuleDefinition, NamedSignature, SignatureInfo, VariantDefinition};
use crate::summarizer::{DocumentationSummary, RenderingContent, RenderingItem};

#[derive(Error, Debug)]
pub enum GenerationError {}

pub fn generate_documentation_site(directory: &PathBuf, summary: DocumentationSummary) -> Result<(), GenerationError> {
    let output_directory = directory.join("doc-site");
    remove_dir(output_directory.clone()).unwrap_or(());
    create_dir_all(output_directory.clone()).expect("Unable to create output directory");

    save_static_file(&output_directory, "style.css", include_bytes!("../design/style.css"));
    save_static_file(&output_directory, "script.js", include_bytes!("../design/script.js"));
    save_static_file(&output_directory, "Uiua386.ttf", include_bytes!("../design/Uiua386.ttf"));
    save_static_file(&output_directory, "index.html", generate_html(summary).as_bytes());

    Ok(())
}

fn save_static_file(output_directory: &PathBuf, file: &str, content: &[u8]) {
    let destination = output_directory.join(file);
    std::fs::write(destination, content).expect("Unable to write static file");
}

fn generate_html(summary: DocumentationSummary) -> String {
    let raw_output = leptos::ssr::render_to_string(|| generate_page(summary)).to_string();
    let document = kuchiki::parse_html().from_utf8().one(raw_output.as_bytes());

    // Remove comments
    document
        .inclusive_descendants()
        .filter(|node| node.as_comment().is_some())
        .for_each(|comment| {
            comment.detach()
        });

    // Remove data-hk attributes generated by leptos
    document
        .select("[data-hk]")
        .unwrap()
        .for_each(|node| {
            node.attributes.borrow_mut().remove("data-hk");
        });

    // Serialize back to string
    let mut result = Vec::new();
    document.serialize(&mut result).unwrap();
    String::from_utf8(result).unwrap()
}

fn markdown_to_html(markdown: &String) -> String {
    markdown::to_html_with_options(
        markdown.as_str(),
        &markdown::Options::gfm()
    ).expect("Unable to convert markdown to HTML")
}

fn generate_page(summary: DocumentationSummary) -> impl IntoView {
    view! {
        <!DOCTYPE html>
        <html lang="en">
            <head>
                <title>{summary.title.clone()}</title>
                <meta charset="utf-8"/>
                <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
                <link rel="stylesheet" href="style.css"/>
                <script src="script.js"></script>
            </head>
            <body>
                <div class="mobile-container">
                    <div class="mobile-nav">
                        <div class="hamburger">
                            <div class="line"></div>
                            <div class="line"></div>
                            <div class="line"></div>
                        </div>
                        <h1>{summary.title.clone()}</h1>
                    </div>
                    <div class="container">
                        <div class="sidebar">
                            {generate_sidebar(&summary)}
                        </div>
                        <div class="content">
                            <div class="content-wrapper">
                                <h1 class="mobile-hidden">{&summary.title}</h1>
                                {generate_content(&summary)}
                            </div>
                        </div>
                    </div>
                </div>
            </body>
        </html>
    }
}

fn generate_sidebar(summary: &DocumentationSummary) -> impl IntoView {
    view! {
        {summary.sections.iter()
            .map(|section| view! {
                <div class="sidebar-section">
                    <div class="section-name">{&section.title}</div>
                    <ul>
                        {section.content.iter()
                            .flat_map(|item| &item.links)
                            .map(|link| view! {
                                <li><a href={&link.url}>{&link.title}</a></li>
                            })
                            .collect_view()
                        }
                        {section.content.iter()
                            .filter(|item| matches!(&item.content, RenderingContent::Items(_)))
                            .map(|link| 
                                match &link.content {
                                    RenderingContent::Items(items) => view! {
                                        <li><a href={format!("#{}", items.title.link_id.clone())}>{items.title.title.clone()}</a></li>
                                    },
                                    _ => view! { <li>"N/A"</li> }
                                }
                            )
                            .collect_view()
                        }
                    </ul>
                </div>
            })
            .collect_view()
        }
    }
}

fn generate_content(summary: &DocumentationSummary) -> impl IntoView {
    view! {
        {summary.sections.iter()
            .map(|section| view! {
                {section.content.iter()
                    .map(|item| generate_rendering_item(item))
                    .collect_view()
                }
            })
            .collect_view()
        }
    }
}

fn generate_rendering_item(item: &RenderingItem) -> impl IntoView {
    match &item.content {
        RenderingContent::RenderedDocumentation(ref content) => view! {
            <div class="panel" inner_html={content}></div>
        },
        RenderingContent::Items(ref item) => view! {
            <div>
                <h2 id={&item.title.link_id}>{&item.title.title}</h2>
                {item.items.iter()
                    .map(|item| generate_content_item(None, item))
                    .collect_view()
                }
            </div>
        },
    }
}

fn generate_content_item(parent_module: Option<String>, item: &ItemContent) -> HtmlElement<Div> {
    match item {
        ItemContent::Binding(binding) => generate_binding_item(parent_module, binding),
        ItemContent::Module(module ) => generate_module_item(parent_module, module),
        ItemContent::Data(data) => generate_data_item(parent_module, data),
        ItemContent::Variant(variant) => generate_variant_item(parent_module, variant),
        _ => view! {
            <div class="panel">{format!("{:?}", item)}</div>
        },
    }
}

fn generate_binding_item(parent_module: Option<String>, item: &BindingDefinition) -> HtmlElement<Div> {
    match &item.kind {
        BindingType::Const(constant) => generate_constant_item(parent_module, item, constant),
        BindingType::Function(function) => generate_function_item(parent_module, item, function),
        BindingType::IndexMacro(index_macro) => generate_index_macro_item(parent_module, item, index_macro),
        BindingType::CodeMacro(code_macro) => generate_code_macro_item(parent_module, item, code_macro),
    }
}

fn generate_constant_item(parent_module: Option<String>, item: &BindingDefinition, constant: &ConstantDefinition) -> HtmlElement<Div> {
    let constant_name = match parent_module {
        Some(parent) => format!("{}~&#x200B;{}", parent, item.name.clone()),
        None => item.name.clone(),
    };
    
    view! {
        <div class="panel">
            <h3 class="mono">
                <span inner_html={constant_name}></span> " " <span class="badge">constant</span>
            </h3>
            {constant.value.as_ref().map(|value| view! {
                <details>
                    <summary>Literal value</summary>
                    <code class="literal-value">{value}</code>
                </details>
            })}
            {item.comment.as_ref().map(|comment|
                view! {
                    <div class="feature-documentation" inner_html={markdown_to_html(comment)}></div>
                }
            )}
        </div>
    }
}

fn generate_named_signature_item(signature: Option<SignatureInfo>, named_signature: Option<NamedSignature>,) -> HtmlElement<Div> {
    let hidden = match signature.is_none() && named_signature.is_none() {
        true => "hidden",
        false => "",
    };
    
    view! {
        <div class=format!("function-summary {}", hidden)>
            {signature.map(|signature|
                view! {
                    <span class="summary-badge signature">{format!("|{}.{}", signature.inputs, signature.outputs)}</span>
                }
            )}
        
            {named_signature.map(|signature|
                view! {
                    {signature.outputs.iter().map(|output|
                        view! {
                            <span class="summary-badge output">{output}</span>
                        }
                    ).collect_view()}
    
                    "?"
    
                    {signature.inputs.iter().map(|input|
                        view! {
                            <span class="summary-badge input">{input}</span>
                        }
                    ).collect_view()}
                }
            )}
        </div>
    }
}

fn generate_function_item(parent_module: Option<String>, item: &BindingDefinition, function: &FunctionDefinition) -> HtmlElement<Div> {
    let function_name = match parent_module {
        Some(parent) => format!("{}~&#x200B;{}", parent, item.name.clone()),
        None => item.name.clone(),
    };
    
    let title_color = match function.signature.inputs {
        0 => "noadic",
        1 => "monadic",
        2 => "dyadic",
        3 => "triadic",
        4 => "tetradic",
        _ => "",
    };
    
    view! {
        <div class="panel">
            <h3 class={format!("mono {}", title_color)}>
                <span inner_html={function_name}></span> " " <span class="badge">function</span>
            </h3>
        
            {generate_named_signature_item(Some(function.signature.clone()), function.named_signature.clone())}
        
            <details>
                <summary>Source code</summary>
                <code class="source-code">{&item.code}</code>
            </details>
            {item.comment.as_ref().map(|comment|
                view! {
                    <div class="feature-documentation" inner_html={markdown_to_html(comment)}></div>
                }
            )}
        </div>
    }
}

fn generate_index_macro_item(parent_module: Option<String>, item: &BindingDefinition, index_macro: &IndexMacroDefinition) -> HtmlElement<Div> {
    let macro_name = match parent_module {
        Some(parent) => format!("{}~&#x200B;{}", parent, item.name.clone()),
        None => item.name.clone(),
    };
    
    let title_color = match index_macro.arguments {
        1 => "monadic-modifier",
        2 => "dyadic-modifier",
        _ => "triadic-modifier",
    };
    
    view! {
        <div class="panel">
            <h3 class={format!("mono {}", title_color)}>
                <span inner_html={macro_name.clone()}></span> " " <span class="badge">index macro</span>
            </h3>
        
            {generate_named_signature_item(None, index_macro.named_signature.clone())}
        
            <details>
                <summary>Source code</summary>
                <code class="source-code">{item.clone().code}</code>
            </details>
        
            {item.comment.as_ref().map(|comment|
                view! {
                    <div class="feature-documentation" inner_html={markdown_to_html(comment)}></div>
                }
            )}
        </div>
    }
}

fn generate_code_macro_item(parent_module: Option<String>, item: &BindingDefinition, index_macro: &CodeMacroDefinition) -> HtmlElement<Div> {
    let macro_name = match parent_module {
        Some(parent) => format!("{}~&#x200B;{}", parent, item.name.clone()),
        None => item.name.clone(),
    };
    
    view! {
        <div class="panel">
            <h3 class="mono monadic-modifier">
                <span inner_html={macro_name.clone()}></span> " " <span class="badge">code macro</span>
            </h3>

            {generate_named_signature_item(None, index_macro.named_signature.clone())}

            <details>
                <summary>Source code</summary>
                <code class="source-code">{item.clone().code}</code>
            </details>

            {item.comment.as_ref().map(|comment|
                view! {
                    <div class="feature-documentation" inner_html={markdown_to_html(comment)}></div>
                }
            )}
        </div>
    }
}

fn generate_module_item(parent_module: Option<String>, module: &ModuleDefinition) -> HtmlElement<Div> {
    let module_name = match parent_module {
        Some(parent) => format!("{}~&#x200B;{}", parent, module.name.clone()),
        None => module.name.clone(),
    };
    
    view! {
        <div class="panel">
            <h3 class="mono module"><span inner_html={module_name.clone()}></span> " " <span class="badge">module</span></h3>
            {module.comment.as_ref().map(|comment|
                view! {
                    <div class="feature-documentation" inner_html={markdown_to_html(comment)}></div>
                }
            )}
            <br/>
            {module.items.iter()
                .map(|item| generate_content_item(Some(module_name.clone()), item))
                .collect_view()
            }
        </div>
    }
}

fn generate_data_item(parent_module: Option<String>, data: &DataDefinition) -> HtmlElement<Div> {
    let data_name = match parent_module {
        Some(parent) => match &data.name {
            Some(name) => format!("{}~&#x200B;{}", parent, name),
            None => parent.clone(),
        }
        None => match &data.name {
            Some(name) => name.clone(),
            None => "".to_string(),
        }
    };
    
    view! {
        <div class="panel">
            <h3 class="mono module">
                <span inner_html={data_name}></span> " " <span class="badge">data</span> " " {
                    if let Some(definition) = &data.definition {
                        match definition.boxed {
                            true => view! { <span class="badge">boxed</span> },
                            false => view! { <span class="badge">unboxed</span> },
                        }
                    } else {
                        view! { <span class="badge">no values</span> }
                    }
                }
            </h3>
            {data.clone().comment.as_ref().map(|comment|
                view! {
                    <div class="feature-documentation" inner_html={markdown_to_html(comment)}></div>
                }
            )}
            {data.clone().definition.map(|definition|
                view! {
                    <div class="data-summary">
                        {definition.fields.iter()
                            .map(|field| {
                                view! {
                                    <div class="badge-row">
                                        <span class="data-badge input">{&field.clone().name}</span>
                                        {&field.clone().validator.map(|validator| {
                                            struct TypeBadge {
                                                name: String,
                                                italics: bool,
                                            }
                                            
                                            let base_type = validator.clone();
                                            let type_name = match validator.as_str() {
                                                "°0type" => TypeBadge {
                                                    name: "number array".to_string(),
                                                    italics: true,
                                                },
                                                "°1type" => TypeBadge {
                                                    name: "complex array".to_string(),
                                                    italics: true,
                                                },
                                                "°2type" => TypeBadge {
                                                    name: "box array".to_string(),
                                                    italics: true,
                                                },
                                                "°3type" => TypeBadge {
                                                    name: "complex array".to_string(),
                                                    italics: true,
                                                },
                                                _ => TypeBadge {
                                                    name: base_type.clone(),
                                                    italics: false,
                                                },
                                            };
                                            let class = match type_name.italics {
                                                true => "data-badge type italics",
                                                false => "data-badge type",
                                            };
                                            
                                            view! {
                                                <span class={class.to_string()}>{type_name.name}</span>
                                            }
                                        }).collect_view()}
                                    </div>
                                }
                            })
                            .collect_view()
                        }
                    </div>
                }
            )}
        </div>
    }
}

fn generate_variant_item(parent_module: Option<String>, data: &VariantDefinition) -> HtmlElement<Div> {
    let variant_name = match parent_module {
        Some(parent) => format!("{}~&#x200B;{}", parent, data.name.clone()),
        None => data.name.clone(),
    };
    
    view! {
        <div class="panel">
            <h3 class="mono module">
                <span inner_html={variant_name}></span> " " <span class="badge">variant</span> " " {
                    if let Some(definition) = &data.definition {
                        match definition.boxed {
                            true => view! { <span class="badge">boxed</span> },
                            false => view! { <span class="badge">unboxed</span> },
                        }
                    } else {
                        view! { <span class="badge">no values</span> }
                    }
                }
            </h3>
            {data.clone().comment.as_ref().map(|comment|
                view! {
                    <div class="feature-documentation" inner_html={markdown_to_html(comment)}></div>
                }
            )}
            {data.clone().definition.map(|definition|
                view! {
                    <div class="data-summary variant">
                        {definition.fields.iter()
                            .map(|field| {
                                view! {
                                    <div class="badge-row">
                                        <span class="data-badge input">{field.clone().name}</span>
                                    </div>
                                }
                            }).collect_view()
                        }
                    </div>
                }
            )}
        </div>
    }
}